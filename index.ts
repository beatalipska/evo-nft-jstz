type A=string;type T=number;
const SK="s",MK="m";
function gS():{t:number;o:A[];m:string[]}{const s=Kv.get(SK)as string|null;return s?JSON.parse(s):{t:0,o:[],m:[]};}
function sS(d:{t:number;o:A[];m:string[]}){Kv.set(SK,JSON.stringify(d));}
function gM(i:T):any{const s=Kv.get(`${MK}_${i}`)as string|null;return s?JSON.parse(s):null;}
function sM(i:T,m:any){Kv.set(`${MK}_${i}`,JSON.stringify(m));}
function getMs(l:number):string[]{const ms=[];if(l>=1)ms.push("LVL_1");if(l>=5)ms.push("LVL_5");if(l>=10)ms.push("LVL_10");if(l>=20)ms.push("LVL_20");return ms;}
function buildM(i:T,s:{t:number;o:A[];m:string[]}):any{const l=s.t;const v=s.m.includes("LVL_20")?"Legendary":s.m.includes("LVL_10")?"Epic":s.m.includes("LVL_5")?"Rare":"Common";const c=s.m.includes("LVL_10")?"Iridescent":"Blue";return{name:`Evolving Crystal #${i} â€“ Level ${l}`,description:"An evolving NFT that grows with every collector. Each purchase adds a new facet and records its owner.",growthLevel:l,variant:v,color:c,image:`https://assets.example/jstz-crystal?level=${l}&variant=${v}`,attributes:[{name:"Growth Level",value:l.toString()},{name:"Variant",value:v},{name:"Color",value:c},{name:"Unique Owners",value:s.o.length.toString()},{name:"Milestones",value:s.m.join(", ")||"None"}],history:{owners:s.o,totalPurchases:l},milestones:s.m};}
const handler=async(r:Request):Promise<Response>=>{const u=new URL(r.url),pathname=u.pathname||"",m=r.method,req=r.headers.get("Referer")as A||"unknown";let p=pathname.toLowerCase().replace(/^\/+|\/+$/g,"");if(p.includes("/")){const parts=p.split("/");p=parts[parts.length-1]||"";if(parts.length>1&&parts[parts.length-2])p=parts[parts.length-2]+"/"+p;}try{if(m==="GET"&&(p.startsWith("metadata/")||pathname.includes("metadata/"))){const parts=pathname.toLowerCase().split("/");let i=0;for(let j=0;j<parts.length;j++){if(parts[j]==="metadata"&&parts[j+1]){i=Number(parts[j+1])||0;break;}}if(isNaN(i))return Response.json({error:"Invalid tokenId"},{status:400});const s=gS();const meta=buildM(i,s);return Response.json(meta);}if((p==="purchase"||p.includes("purchase")||pathname.includes("purchase"))&&m==="POST"){const b=await r.json()as{buyer?:A;tokenId?:T};const buyer=b.buyer||req;const tid=b.tokenId||0;if(tid!==0)return Response.json({error:"Only tokenId 0 supported"},{status:400});let s=gS();s.t++;if(!s.o.includes(buyer))s.o.push(buyer);s.m=getMs(s.t);sS(s);const meta=buildM(tid,s);return Response.json({ok:true,state:s,metadata:meta});}if(m==="GET"&&(p==="minter"||p===""||pathname.endsWith("/"))){return Response.json({minter:null});}return Response.json({error:"Not found",path:p,pathname:pathname},{status:404});}catch(e){return Response.json({error:e instanceof Error?e.message:"Error",details:String(e)},{status:500});}};
export default handler;
